version "4.0"

class BarricadeHandler : EventHandler
{
	override void CheckReplacement(ReplaceEvent e)
	{
		if (!e.Replacement)
		{
			return;
		}

		switch (e.Replacement.GetClassName())
		{
			case 'RLReplaces':
				if (random[redrand]() <= 24)
				{
					e.Replacement = "HDDeployableBarricade";
				}
				break;
		}
	}
}

class HDDeployableBarricade : HDPickup
{
	override string PickupMessage()
	{
		string extra = "";
		if (Health < 500)
		{
			extra = " It's barely functional.";
		}
		else if (Health < 1000)
		{
			extra = " It's been seriously roughed up.";
		}
		else if (Health < 2000)
		{
			extra = " 'Tis but a scratch.";
		}
		else if (Health < 3000)
		{
			extra = " It can still stop a lot of bullets.";
		}
		else if (Health < 4000)
		{
			extra = " It has a few dents on it.";
		}
		else if (Health < 4500)
		{
			extra = " It's almost brand new.";
		}
		return Super.PickupMessage()..extra;
	}

	Default
	{
		Health 5000;
		+HDPICKUP.CHEATNOGIVE
		+HDPICKUP.NOTINPOCKETS
		+INVENTORY.INVBAR
		-HDPICKUP.FITSINBACKPACK
		HDPickup.Bulk 250;
		HDPickup.RefID "dab";
		Inventory.MaxAmount 1;
		Inventory.Icon "DABRB0";
		Inventory.PickupMessage "Picked up a deployable barricade.";
		Tag "Deployable barricade";
		XScale 1.4;
		YScale 1.16;
	}

	States
	{
		Spawn:
			DABR A -1;
			Stop;
		Use:
			TNT1 A 0
			{
				bool success; Actor a;

				double sinp = sin(pitch);
				double cosp = cos(pitch);

				double XVel = 1 + (CheckInventory("PowerStrength", 0) ? 3 : 1) * cosp;
				double ZVel = 1 + (CheckInventory("PowerStrength", 0) ? 2 : 1) * -sinp;

				[success, a] = A_SpawnItemEx("HDDeployedBarricade", radius + 4, 0, height / 2 + 8, XVel, 0, ZVel, flags: SXF_NOCHECKPOSITION | SXF_SETMASTER | SXF_TRANSFERTRANSLATION);
				let depBarricade = HDDeployedBarricade(a);
				depBarricade.Health = invoker.Health;
				depBarricade.angle += 180;
				depBarricade.vel += vel;
			}
			Stop;
	}
}

class HDDeployedBarricade : HDActor
{
	override void Tick()
	{
		Super.Tick();
		if (GetAge() % 10 == 0 && TimesUsed > 0)
		{
			TimesUsed--;
		}
		// if (!IsFrozen())
		// {
		// 	AceCore.DrawCollisionBox(self, 0xFF0000, 1, 1);
		// }
	}

	override bool Used(Actor user)
	{
		if (!Deployed || Distance3D(user) > 50)
		{
			return false;
		}
		else if (TimesUsed < 4)
		{
			TimesUsed++;
			return false;
		}
		
		A_StartSound("doors/dr1_clos", pitch: 1.1);
		SetStateLabel('UnDeploy');
		return true;
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		if (other == master)
		{
			return false;
		}

		return Super.CanCollideWith(other, passive);
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		if (Health > 0)
		{
			Health -= ApplyDamageFactor(mod, damage);
			if (Health <= 0)
			{
				SetStateLabel('Boom');
			}
		}
		return 0;
	}

	bool Deployed;
	int TimesUsed;
	Array<BarricadeBarricade> CenterSegments;
	Array<BarricadeBarricade> LeftSideSegments;
	Array<BarricadeBarricade> RightSideSegments;
	private int Offset;

	Default
	{
		Radius 30;
		Height 20;
		Mass 20000;
		Friction 0.95;
		Renderstyle "Normal";
		DamageFactor "Hot", 0.15;
		DamageFactor "Balefire", 0.05;
		DamageFactor "Burning", 0.15;
		DamageFactor "Electrical", 0.05;
		DamageFactor "Holy", 0;
		Gravity 1.5;
		Friction 0.5;
		+SOLID
	}

	States
	{
		Spawn:
			DPBR A 1
			{
				if (vel.length() < 0.4)
				{
					A_Stop();
					SetStateLabel('Deploy');
					A_StartSound("doors/dr1_open", pitch: 1.1);
					bSOLID = false;
					for (double i = -Radius; i <= Radius; i += 6)
					{
						Actor a; bool success;
						[success, a] = A_SpawnItemEx("BarricadeBarricade", 0, i, flags: SXF_SETMASTER);
						let br = BarricadeBarricade(a);
						br.A_SetSize(-1, Height);
						br.Core = true;
						br.Offset = i;
						CenterSegments.Push(br);
					}
					return;
				}
			}
			Loop;
		Deploy:
			DPBR A 3;
			DPBR ABCDE 2
			{
				for (int i = 0; i < CenterSegments.Size(); ++i)
				{
					CenterSegments[i].A_SetSize(-1, CenterSegments[i].Height + 4);
				}
				A_SetSize(-1, Height + 4);
			}
			DPBR E 3;
			DPBR FGHIJ 2
			{
				Actor a; bool success; BarricadeBarricade br;

					double off = (Radius + 6 + Offset);

					[success, a] = A_SpawnItemEx("BarricadeBarricade", 0, off, 0, flags: SXF_SETMASTER);
					br = BarricadeBarricade(a);
					br.A_SetSize(-1, Height);
					br.Offset = off;
					LeftSideSegments.Push(br);

					[success, a] = A_SpawnItemEx("BarricadeBarricade", 0, -off, 0, flags: SXF_SETMASTER);
					br = BarricadeBarricade(a);
					br.A_SetSize(-1, Height);
					br.Offset = -off;
					RightSideSegments.Push(br);

					Offset += 6;
			}
			DPBR J 3;
			DPBR KLMNO 2
			{
				for (int i = 0; i < LeftSideSegments.Size(); ++i)
				{
					LeftSideSegments[i].A_SetSize(-1, LeftSideSegments[i].Height + 3.5);
				}
				for (int i = 0; i < RightSideSegments.Size(); ++i)
				{
					RightSideSegments[i].A_SetSize(-1, RightSideSegments[i].Height + 3.5);
				}
			}
		Idle:
			DPBR # -1
			{
				Deployed = true;
			}
			Stop;

		UnDeploy:
			DPBR ONMLK 2
			{
				Deployed = false;
				for (int i = 0; i < LeftSideSegments.Size(); ++i)
				{
					LeftSideSegments[i].A_SetSize(-1, LeftSideSegments[i].Height - 3.5);
				}
				for (int i = 0; i < RightSideSegments.Size(); ++i)
				{
					RightSideSegments[i].A_SetSize(-1, RightSideSegments[i].Height - 3.5);
				}
			}
			DPBR K 2;
			DPBR JIHGF 2
			{
				for (int i = 0; i < 2; ++i)
				{
					int lsize = LeftSideSegments.Size();
					if (lsize > 0)
					{
						LeftSideSegments[lsize - 1].Destroy();
						LeftSideSegments.Pop();
					}
					int rsize = RightSideSegments.Size();
					if (rsize > 0)
					{
						RightSideSegments[rsize - 1].Destroy();
						RightSideSegments.Pop();
					}
				}
			}
			DPBR EDCBA 2
			{
				for (int i = 0; i < CenterSegments.Size(); ++i)
				{
					CenterSegments[i].A_SetSize(-1, CenterSegments[i].Height - 4);
				}
				A_SetSize(-1, Height - 4);
			}
			DPBR A 0
			{
				Actor a = Spawn('HDDeployableBarricade', pos);
				a.Health = Health;
			}
			Stop;
		Boom:
			TNT1 A 1
			{
				for (int i = 0; i < CenterSegments.Size(); ++i)
				{
					CenterSegments[i].Destroy();
				}
				for (int i = 0; i < LeftSideSegments.Size(); ++i)
				{
					LeftSideSegments[i].Destroy();
				}
				for (int i = 0; i < RightSideSegments.Size(); ++i)
				{
					RightSideSegments[i].Destroy();
				}

				A_StartSound("weapons/bigcrack", CHAN_AUTO);
				A_StartSound("world/explode", CHAN_VOICE);
				A_SpawnChunks("HDExplosion", 6, 0, 1);
				A_SpawnItemEx("HDExplosion");
				DistantQuaker.Quake(self, 2, 35, 256, 10);
				A_HDBlast(pushradius: 256, pushamount: 128, fullpushradius: 96, fragradius: 256, fragtype: "HDB_Frag");
			}
			Stop;
	}
}

// [Ace] No, this isn't a typo.
class BarricadeBarricade : HDActor
{
	override void Tick()
	{
		Super.Tick();

		let br = HDDeployedBarricade(master);
		if (!br)
		{
			Destroy();
			return;
		}

		// [Ace] Nuke the thing if it gets automatically moved by the engine.
		if (floorz - 8 > br.floorz)
		{
			if (Core && br.Deployed)
			{
				br.Deployed = false;
				br.SetStateLabel('UnDeploy');
				return;
			}

			int leftIndex = br.LeftSideSegments.Find(self);
			if (leftIndex != br.LeftSideSegments.Size())
			{
				br.LeftSideSegments.Delete(leftIndex);
				Destroy();
				return;
			}

			int rightIndex = br.RightSideSegments.Find(self);
			if (rightIndex != br.RightSideSegments.Size())
			{
				br.RightSideSegments.Delete(rightIndex);
				Destroy();
				return;
			}
		}

		Warp(master, 0, Offset, 0, flags: WARPF_NOCHECKPOSITION);
		// if (!IsFrozen())
		// {
		// 	AceCore.DrawCollisionBox(self, 0xFF0000, 1, 1);
		// }
	}

	override int DamageMobj(Actor inflictor, Actor source, int damage, Name mod, int flags, double angle)
	{
		master.DamageMobj(inflictor, source, damage, mod, flags, angle);
		return 0;
	}

	override double BulletResistance(double hitangle)
	{
		return Super.BulletResistance(hitangle) * 35;
	}

	override bool Used(Actor user)
	{
		master.Used(user);
		return true;
	}

	bool Core;
	double Offset;

	Default
	{
		Radius 3.5;
		Height 10;
		Mass 10000;
		+SOLID
		+SHOOTABLE
		+NODAMAGE
		+NOBLOOD
		+FORCEYBILLBOARD
		+DONTTHRUST
		+WALLSPRITE
		+NOFRICTIONBOUNCE
		+NOLIFTDROP
	}

	States
	{
		Spawn:
			TNT1 A -1;
			STop;
	}
}